//
// Z80 Memory modelling and management
//

#ifndef SJASMPLUS_MEMORY_H
#define SJASMPLUS_MEMORY_H

#include <string>
#include <map>
#include <vector>
#include <array>
#include <cstdint>
#include <boost/optional.hpp>
#include "errors.h"

using namespace std::string_literals;

class MemModel {
protected:
    std::string Name;
    bool ZXSysVarsInitialized = false;
public:
    MemModel(const std::string &name) { Name = name; }

    virtual ~MemModel() = 0;

    const std::string &GetName() { return Name; }

    virtual bool IsPagedMemory() = 0;

    virtual int NumMemPages() = 0;

    virtual int GetPageNumInSlot(int slot) = 0;

    virtual void WriteByte(uint16_t addr, uint8_t byte) = 0;

    // Return error string on error
    virtual boost::optional<std::string> SetPage(int slot, int page) = 0;

    virtual boost::optional<std::string> SetPage(uint16_t currentAddr, int page) = 0;

    virtual boost::optional<std::string> ValidateSlot(int slot) = 0;

    virtual int GetPageForAddress(uint16_t currentAddr) = 0;

    // TODO: replace with safer version
    virtual void GetBytes(uint8_t *dest, uint16_t addr, uint16_t size) = 0;

    virtual void GetBytes(uint8_t *dest, int slot, uint16_t addrInPage, uint16_t size) = 0;

    virtual uint8_t *GetPtrToMem() = 0;

    virtual void Clear() = 0;

    virtual uint8_t *GetPtrToPage(int page) = 0;

    virtual uint8_t *GetPtrToPageInSlot(int slot) = 0;

    virtual void InitZXSysVars() = 0;
};

// Plain 64K without paging
class PlainMemModel : public MemModel {
private:
    std::array<uint8_t, 0x10000> Memory;
public:
    PlainMemModel() : MemModel{"PLAIN"s} {
        Memory.fill(0);
    }

    virtual ~PlainMemModel() override {}

    bool IsPagedMemory() override { return false; }

    virtual int NumMemPages() override { return 0; }

    virtual int GetPageNumInSlot(int slot) override { return 0; }

    virtual boost::optional<std::string> SetPage(int slot, int page) override {
        return "The PLAIN memory model does not support page switching"s;
    }

    virtual boost::optional<std::string> SetPage(uint16_t currentAddr, int page) override {
        return SetPage((int) 0, 0);
    }

    virtual boost::optional<std::string> ValidateSlot(int slot) override {
        return SetPage((int) 0, (int) 0);
    }

    virtual int GetPageForAddress(uint16_t currentAddr) override {
        return 0;
    }

    virtual void GetBytes(uint8_t *dest, uint16_t addr, uint16_t size) override {
        for (int i = 0; i < size; i++) {
            *(dest + i) = Memory[addr + i];
        }
    }

    virtual void GetBytes(uint8_t *dest, int slot, uint16_t addrInPage, uint16_t size) override {
        Error("GetBytes(): "s + *(SetPage(0, 0)), ""s, FATAL);
    }

    virtual uint8_t *GetPtrToMem() override {
        return Memory.data();
    }

    virtual void Clear() override {
        Memory.fill(0);
    }

    virtual uint8_t *GetPtrToPage(int page) override {
        Error("GetPtrToPage(): "s + *(SetPage(0, 0)), ""s, FATAL);
        return nullptr;
    }

    virtual uint8_t *GetPtrToPageInSlot(int slot) override {
        Error("GetPtrToPageInSlot(): "s + *(SetPage(0, 0)), ""s, FATAL);
        return nullptr;
    }

    virtual void WriteByte(uint16_t addr, uint8_t byte) override {
        Memory[addr] = byte;
    }

    virtual void InitZXSysVars() override;
};

// ZX Spectrum 128, 256, 512, 1024 with 4 slots of 16K each
class ZXMemModel : public MemModel {
private:
    const size_t PageSize = 0x4000;
    int NPages;
    int NSlots = 4;
    int SlotPages[4] = {0, 5, 2, 7};
    std::vector<uint8_t> Memory;

    uint8_t ReadByte(uint16_t addr) {
        return Memory[SlotPages[addr / PageSize] * PageSize + (addr % PageSize)];
    }

public:
    ZXMemModel(const std::string &name, int nPages);

    virtual ~ZXMemModel() override {}

    virtual void GetBytes(uint8_t *dest, uint16_t addr, uint16_t size) override {
        for (int i = 0; i < size; i++) {
            *(dest + i) = ReadByte(addr + i);
        }
    }

    virtual void GetBytes(uint8_t *dest, int slot, uint16_t addrInPage, uint16_t size) override {
        uint16_t addr = addrInPage + slot * PageSize;
        for (int i = 0; i < size; i++) {
            *(dest + i) = ReadByte(addr + i);
        }
    }

    virtual uint8_t *GetPtrToMem() override {
        return Memory.data();
    }

    virtual void Clear() override {
        Memory.assign(Memory.size(), 0);
    }

    virtual uint8_t *GetPtrToPage(int page) override {
        return Memory.data() + page * PageSize;
    }

    virtual uint8_t *GetPtrToPageInSlot(int slot) override {
        return Memory.data() + SlotPages[slot] * PageSize;
    }

    void WriteByte(uint16_t addr, uint8_t byte) override {
        Memory[SlotPages[addr / PageSize] * PageSize + (addr % PageSize)] = byte;
    }

    bool IsPagedMemory() override { return true; }

    virtual int NumMemPages() override { return NPages; }

    virtual int GetPageNumInSlot(int slot) override { return SlotPages[slot]; }

    virtual boost::optional<std::string> SetPage(int slot, int page) override;

    virtual boost::optional<std::string> SetPage(uint16_t currentAddr, int page) override;

    virtual boost::optional<std::string> ValidateSlot(int slot) override;

    virtual int GetPageForAddress(uint16_t currentAddr) override;

    virtual void InitZXSysVars() override;
};

// MemoryManager knows about memory models and manages them, and is used to collect assembler's output
class MemoryManager {

private:
    std::map<std::string, MemModel *> MemModels;
    MemModel *CurrentMemModel;

    const std::map<std::string, int> MemModelNames = {
            {"PLAIN"s,          0},
            {"ZXSPECTRUM128"s,  8},
            {"ZXSPECTRUM256"s,  16},
            {"ZXSPECTRUM512"s,  32},
            {"ZXSPECTRUM1024"s, 64}
    };

public:
    MemoryManager();

    ~MemoryManager();

    void SetMemModel(const std::string &name);

    const std::string &GetMemModelName() {
        return CurrentMemModel->GetName();
    }

    bool IsPagedMemory() {
        return CurrentMemModel->IsPagedMemory();
    }

    int NumMemPages() {
        return CurrentMemModel->NumMemPages();
    }

    int GetPageNumInSlot(int slot) {
        return CurrentMemModel->GetPageNumInSlot(slot);
    }

    boost::optional<std::string> SetPage(int slot, int page) {
        return CurrentMemModel->SetPage(slot, page);
    }

    boost::optional<std::string> SetPage(uint16_t currentAddr, int page) {
        return CurrentMemModel->SetPage(currentAddr, page);
    }

    boost::optional<std::string> ValidateSlot(int slot) {
        return CurrentMemModel->ValidateSlot(slot);
    }

    int GetPageForAddress(uint16_t addr) {
        return CurrentMemModel->GetPageForAddress(addr);
    }

    void GetBytes(uint8_t *dest, uint16_t addr, uint16_t size) {
        CurrentMemModel->GetBytes(dest, addr, size);
    }

    void GetBytes(uint8_t *dest, int slot, uint16_t addrInPage, uint16_t size) {
        CurrentMemModel->GetBytes(dest, slot, addrInPage, size);
    }

    uint8_t *GetPtrToMem() {
        return CurrentMemModel->GetPtrToMem();
    }

    void Clear() {
        return CurrentMemModel->Clear();
    }

    uint8_t *GetPtrToPage(int page) {
        return CurrentMemModel->GetPtrToPage(page);
    }

    uint8_t *GetPtrToPageInSlot(int slot) {
        return CurrentMemModel->GetPtrToPageInSlot(slot);
    }

    void WriteByte(uint16_t addr, uint8_t byte) {
        CurrentMemModel->WriteByte(addr, byte);
    }

    void InitZXSysVars() {
        CurrentMemModel->InitZXSysVars();
    }
};


const uint8_t ZXSysVars[] = {
        0x0D, 0x03, 0x20, 0x0D, 0xFF, 0x00, 0x1E, 0xF7,
        0x0D, 0x23, 0x02, 0x00, 0x00, 0x00, 0x16, 0x07,
        0x01, 0x00, 0x06, 0x00, 0x0B, 0x00, 0x01, 0x00,
        0x01, 0x00, 0x06, 0x00, 0x3E, 0x3F, 0x01, 0xFD,
        0xDF, 0x1E, 0x7F, 0x57, 0xE6, 0x07, 0x6F, 0xAA,
        0x0F, 0x0F, 0x0F, 0xCB, 0xE5, 0xC3, 0x99, 0x38,
        0x21, 0x00, 0xC0, 0xE5, 0x18, 0xE6, 0x00, 0x3C,
        0x40, 0x00, 0xFF, 0xCC, 0x01, 0xFC, 0x5F, 0x00,
        0x00, 0x00, 0xFE, 0xFF, 0xFF, 0x01, 0x00, 0x02,
        0x38, 0x00, 0x00, 0xD8, 0x5D, 0x00, 0x00, 0x26,
        0x5D, 0x26, 0x5D, 0x3B, 0x5D, 0xD8, 0x5D, 0x3A,
        0x5D, 0xD9, 0x5D, 0xD9, 0x5D, 0xD7, 0x5D, 0x00,
        0x00, 0xDB, 0x5D, 0xDB, 0x5D, 0xDB, 0x5D, 0x2D,
        0x92, 0x5C, 0x10, 0x02, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x4A, 0x17, 0x00, 0x00,
        0xBB, 0x00, 0x00, 0x58, 0xFF, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x21, 0x17, 0x00, 0x40, 0xE0, 0x50,
        0x21, 0x18, 0x21, 0x17, 0x01, 0x38, 0x00, 0x38,
        0x00, 0x00, 0xAF, 0xD3, 0xF7, 0xDB, 0xF7, 0xFE,
        0x1E, 0x28, 0x03, 0xFE, 0x1F, 0xC0, 0xCF, 0x31,
        0x3E, 0x01, 0x32, 0xEF, 0x5C, 0xC9, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xFF, 0x5F, 0xFF, 0xFF, 0xF4, 0x09,
        0xA8, 0x10, 0x4B, 0xF4, 0x09, 0xC4, 0x15, 0x53,
        0x81, 0x0F, 0xC9, 0x15, 0x52, 0x34, 0x5B, 0x2F,
        0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x22,
        0x31, 0x35, 0x36, 0x31, 0x36, 0x22, 0x03, 0xDB,
        0x5C, 0x3D, 0x5D, 0xA2, 0x00, 0x62, 0x6F, 0x6F,
        0x74, 0x20, 0x20, 0x20, 0x20, 0x42, 0x9D, 0x00,
        0x9D, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x08, 0x00, 0x00,
        0x00, 0x00, 0x08, 0xFF, 0xFF, 0xFF, 0x80, 0x00,
        0x00, 0xFF, 0xFA, 0x5C, 0xFA, 0x5C, 0x09, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00,
        0x00, 0x3C, 0x5D, 0xFC, 0x5F, 0xFF, 0x3C, 0xAA,
        0x00, 0x00, 0x01, 0x02, 0xF8, 0x5F, 0x00, 0x00,
        0xF7, 0x22, 0x62
};

const uint8_t BASin48Vars[] = {
        0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x23, 0x05, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x06, 0x00, 0x0b, 0x00, 0x01, 0x00, 0x01, 0x00,
        0x06, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x3c, 0x40, 0x00, 0xff, 0xc0, 0x01, 0x54, 0xff, 0x00, 0x00,
        0x00, 0x00, 0x00, 0xff, 0xfe, 0xff, 0x01, 0x38, 0x00, 0x00, 0xcb, 0x5c, 0x00,
        0x00, 0xb6, 0x5c, 0xb6, 0x5c, 0xcb, 0x5c, 0xdb, 0x5c, 0xca, 0x5c, 0xcc, 0x5c,
        0xd4, 0x5c, 0xda, 0x5c, 0xcf, 0x00, 0xdc, 0x5c, 0xdc, 0x5c, 0xdc, 0x5c, 0x2d,
        0x92, 0x5c, 0x10, 0x02, 0x00, 0x00, 0xfe, 0xff, 0x01, 0x00, 0x00, 0x00, 0xb6,
        0x1a, 0x00, 0x00, 0xe5, 0x00, 0x00, 0x58, 0xff, 0x00, 0x00, 0x21, 0x00, 0x5b,
        0x21, 0x17, 0x00, 0x40, 0xe0, 0x50, 0x21, 0x18, 0x21, 0x17, 0x01, 0x38, 0x00,
        0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x57, 0xff, 0xff, 0xff,
        0xf4, 0x09, 0xa8, 0x10, 0x4b, 0xf4, 0x09, 0xc4, 0x15, 0x53, 0x81, 0x0f, 0xc4,
        0x15, 0x52, 0xf4, 0x09, 0xc4, 0x15, 0x50, 0x80, 0x80, 0xf9, 0xc0, 0x33, 0x32,
        0x37, 0x36, 0x38, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x80, 0x00, 0x0d, 0x80, 0x00,
        0x00, 0x00, 0x80, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const uint8_t BASin48SP[] = {
        0xb1, 0x33, 0xe0, 0x5c, 0xc2, 0x02, 0x4d, 0x00, 0xdc, 0x5c, 0x00, 0x80, 0x2b,
        0x2d, 0x54, 0x00, 0x2b, 0x2d, 0x2b, 0x2d, 0x65, 0x33, 0x00, 0x00, 0xed, 0x10,
        0x0d, 0x00, 0x09, 0x00, 0x85, 0x1c, 0x10, 0x1c, 0x52, 0x1b, 0x76, 0x1b, 0x03,
        0x13, 0x00, 0x3e, 0x00, 0x3c, 0x42, 0x42, 0x7e, 0x42, 0x42, 0x00, 0x00, 0x7c,
        0x42, 0x7c, 0x42, 0x42, 0x7c, 0x00, 0x00, 0x3c, 0x42, 0x40, 0x40, 0x42, 0x3c,
        0x00, 0x00, 0x78, 0x44, 0x42, 0x42, 0x44, 0x78, 0x00, 0x00, 0x7e, 0x40, 0x7c,
        0x40, 0x40, 0x7e, 0x00, 0x00, 0x7e, 0x40, 0x7c, 0x40, 0x40, 0x40, 0x00, 0x00,
        0x3c, 0x42, 0x40, 0x4e, 0x42, 0x3c, 0x00, 0x00, 0x42, 0x42, 0x7e, 0x42, 0x42,
        0x42, 0x00, 0x00, 0x3e, 0x08, 0x08, 0x08, 0x08, 0x3e, 0x00, 0x00, 0x02, 0x02,
        0x02, 0x42, 0x42, 0x3c, 0x00, 0x00, 0x44, 0x48, 0x70, 0x48, 0x44, 0x42, 0x00,
        0x00, 0x40, 0x40, 0x40, 0x40, 0x40, 0x7e, 0x00, 0x00, 0x42, 0x66, 0x5a, 0x42,
        0x42, 0x42, 0x00, 0x00, 0x42, 0x62, 0x52, 0x4a, 0x46, 0x42, 0x00, 0x00, 0x3c,
        0x42, 0x42, 0x42, 0x42, 0x3c, 0x00, 0x00, 0x7c, 0x42, 0x42, 0x7c, 0x40, 0x40,
        0x00, 0x00, 0x3c, 0x42, 0x42, 0x52, 0x4a, 0x3c, 0x00, 0x00, 0x7c, 0x42, 0x42,
        0x7c, 0x44, 0x42, 0x00, 0x00, 0x3c, 0x40, 0x3c, 0x02, 0x42, 0x3c, 0x00, 0x00,
        0xfe, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42,
        0x3c, 0x00, 0x00
};

#endif //SJASMPLUS_MEMORY_H
